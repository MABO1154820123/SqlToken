name: SqlTokenRefresh

on:
  schedule:
    - cron: '0 */23 * * *'  # 每23小时执行一次
  workflow_dispatch:  # 允许手动触发运行
  repository_dispatch:
    types: [update-sql-token]  # 允许通过API触发

permissions:
  contents: read  # 仅需要读取权限，因为我们只写入本地文件

jobs:
  get-sql-token:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install requests

      - name: Get SQL Token and write to file
        run: |
          python -c "
          import os
          import json
          import requests
          import time
          from datetime import datetime

          print(f'[INFO] 开始执行: {time.strftime(\"%Y-%m-%d %H:%M:%S\")}')
          
          # 数据库连接配置
          SQL_API_URL = 'https://client.sqlpub.com/api/connection'
          connection_config = {
              'host': '${{ secrets.DB_HOST }}',
              'port': int('${{ secrets.DB_PORT }}'),
              'dbName': '${{ secrets.DB_NAME }}',
              'dbUser': '${{ secrets.DB_USER }}',
              'password': '${{ secrets.DB_PASSWORD }}'
          }

          try:
              # 获取SQL Token
              print(f'[INFO] 发送请求到SQL API: {SQL_API_URL}')
              headers = {
                  'accept': 'application/json',
                  'content-type': 'application/json'
              }
              
              response = requests.post(
                  SQL_API_URL,
                  headers=headers,
                  json=connection_config,
                  timeout=10
              )
              
              print(f'[INFO] API响应状态: {response.status_code}')
              response.raise_for_status()
              
              data = response.json()
              if data.get('success') and data.get('data') and 'token' in data['data']:
                  sql_token = data['data']['token']
                  print('[SUCCESS] 成功获取SQL Token')
                  
                  # 写入sqlToken.txt文件
                  current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                  token_file_content = f'上次更新时间：\n{current_time}\nsqlToken：\n{sql_token}'
                  with open('sqlToken.txt', 'w', encoding='utf-8') as f:
                      f.write(token_file_content)
                  print('[SUCCESS] 成功将SQL Token写入sqlToken.txt文件')
                  exit(0)
              else:
                  print('[ERROR] API响应中未找到有效token')
                  # 创建包含错误信息的token文件
                  current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                  token_file_content = f'上次更新时间：\n{current_time}\nsqlToken：\n无有效token'
                  with open('sqlToken.txt', 'w', encoding='utf-8') as f:
                      f.write(token_file_content)
                  exit(1)
          
          except Exception as e:
              print(f'[ERROR] 执行过程中出错: {str(e)}')
              # 创建包含错误信息的token文件
              try:
                  current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                  token_file_content = f'上次更新时间：\n{current_time}\nsqlToken：\n获取失败: {str(e)}'
                  with open('sqlToken.txt', 'w', encoding='utf-8') as f:
                      f.write(token_file_content)
                  print('[INFO] 已创建包含错误信息的sqlToken.txt文件')
              except:
                  pass
              exit(1)
          "

      - name: Verify token file
        if: always()
        run: |
          echo "=== 执行结果验证 ==="
          if [ -f "sqlToken.txt" ]; then
            echo "sqlToken.txt文件已生成"
            echo "文件内容前8个字符: $(head -c 8 sqlToken.txt)..."
          else
            echo "错误: 未找到sqlToken.txt文件"
          fi